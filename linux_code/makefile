hello:hello.o
	gcc hello.o -o hello
hello.o:hello.s
	gcc -c hello.s -o hello.o
hello.s:hello.i
	gcc -S hello.i -o hello.s
hello.i:hello.c
	gcc -E hello.c -o hello.i


.PHONY:clean
clean:
	rm -rf hello.i hello.s hello.o hello
#makefile的编写规则既是这样
#目标对象：依赖关系
#[tab]依赖方法
#为了生成目标对象，而去寻找依赖对象，通过依赖方法来使依赖对象生成目标对象，并且只会为了生成第一个目标对象而去找第一个依赖对象，当发现第一个依赖对象不存在，才会为了能使用第一个依赖对象，而去继续寻找下一个依赖关系生成这个依赖对象，依次往复

#.PHONY既是伪目标，用以生成那些每次都需要执行的目标文件，这里由于make具有每次执行后将生成文件与已存在的文件对比，如果发现目标文件存在就不会重新生成，而这里需要每次对某些文件的清理都要执行，因此将清理工作设定为伪目标

#同时，此处也复习了gcc的编译过程：
#1.预处理过程:此处主要是进行代码展开，宏的文本替换等，通过 gcc *.c -o *.i 生成*.i文件既是代码的展开
#2.编译过程，将已经展开的C语言代码翻译成汇编语言代码：gcc -S *.i -o *.s *.s文件就是汇编语言代码
#3.汇编过程：将汇编代码进行汇编生成机器能够识别的代码，此时的代码已经是二进制码了，无法直接进行查看，需要进行反编译成汇编语言才能进行查看，汇编过程：gcc -c *.s -o *.o *.o文件是只有计算机能够识别的，反汇编指令是：objdump -S *.o 对文件进行反汇编
#4.链接过程，链接是把生成的*.o文件与C语言函数库文件进行连接，以生成可执行文件 gcc *.o -o 
